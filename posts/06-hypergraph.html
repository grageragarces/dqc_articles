<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Partitioning Hypergraphs in DQC</title>
  <link rel="stylesheet" href="../style.css" />
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
</head>
<body>
  <article>
    <h1>Partitioning Hypergraphs in DQC</h1>
    <p><em>?th of January 2026</em></p>

    <p>
    ABSTRACT
    </p>

    <p><a href="../index.html">← Back to all posts</a></p>
 
<section>
  <div style="background-color:#fff8dc; border-left:4px solid #e6d87c; padding:10px 15px; margin:10px 0;">
    <strong>Graph:</strong> A mathematical structure consisting of <em>nodes</em> (vertices) and <em>edges</em> that connect pairs of nodes. 
    Each edge links <em>two</em> nodes together.
  <br>
    <strong>Hypergraph:</strong> A generalization of a graph where edges (called <em>hyperedges</em>) 
    can connect any number of nodes, <em>not</em> just two. 
    A hyperedge can link two, three, four, or more nodes simultaneously.
    You can think of a hypergraph as a collection of groups, where each hyperedge defines one group of interconnected nodes.
  </div>

<figure style="text-align: center; margin: 20px 0;">
  <img src="../images/graph_hyper.png" alt="Graph and Hypergraph illustration" 
        style="max-width: 400px; max-height: 400px; height: auto; width: auto; object-fit: contain;">
  <figcaption style="margin-top: 10px; font-style: italic; color: #666;">
    Illustration of a graph (left) and a hypergraph (right). 
    In the graph, edges connect pairs of nodes, while in the hypergraph, hyperedges can connect multiple nodes simultaneously.
    Taken from <a href="https://commons.wikimedia.org/wiki/File:Graph_and_hypergraph.svg" target="_blank">Wikimedia Commons</a>.
  </figcaption> 
</figure>

Hypergraphs are a mathematical structure that allow us to encode relationships between different entities.
In distributed quantum computing, they are used to encode the relationships between qubits, such that when these are assigned to different quantum processors, 
if they hold some connection between them (let's say through a CX gate in the computation), 
this connection is respected accross the devices through whichever links connect the QPUs.
Meaning that if we allot groups of qubits needed for a distributed computation to two interconnected QPUs, 
a hypergraph abstraction of this computation allows us to see which hyperedges separate both groups, 
and thus signify the need for non-local operations (such as a teleportation or cat-entagler).

<br>
This way of modeling distributed quantum computations has intertwined hypergraph theory with the field of DQC.
In this blog post I will dive into hypergraph partitioning heuristics designed to tackle the hypergraph partitioning problem, 
which is a very well known NP-hard problem in computer science, but may not be the best fit for DQC.

</section>

<section> 
  <h2>Hypergraphs in DQC</h2>
  <!-- ARE WE REPEATING OURSELVES FROM THE ABSTRACT? -->
Hypergraph based representations came into the Distributed Quantum computing sphere back in 2018 through Martinez & Heunen's <a href="https://arxiv.org/abs/1811.10972" target="_blank">Automated distribution of quantum circuits via hypergraph partitioning</a>.
Hypergraphs serve as a very natural abstraction of the dependencies that must be maintained accross sub-workloads of a larger computation, 
which is a crucial part of the DQC problem: how do I cut up my computational pie such that my cut up pie is equivalent to my original?
The original proposal was to represent qubits as the items/nodes of a hypergraph and quantum gates as the hyperedges connecting these qubits.
Meaning that the computational dependencies generated multi-qubit gates, which are in essense entangling gates, were now encoded into this abstraction.

  <div style="background-color:#fff8dc; border-left:4px solid #e6d87c; padding:10px 15px; margin:10px 0;">
    <strong>Non-local gate:</strong> Entangling gate (meaning a multi-qubit gate, such as a CX or CZ) that operates on qubits located in different QPUs within a distributed quantum computing system.
    Non-local gates preserve entanglement, meaning they consume the entanglement generated by the quantum network to enable inter-QPU operations.
    There are different ways/protocols to implement the same non-local gate. 
    The general idea is to use teleportation-based protocols to enable them.
    The specific method used is often called a <em>communication primitive</em>.
    
    <br><br>
    
    <strong>Communication primitive (DQC):</strong> A communication primitive can be thought as the implementation strategy for non-local gates.
    It defines the translation from a multi-qubit gates acting between QPUs into a series of quantum operations that can be executed within the relevant devices, using the quantum network, to implement an equivalent non-local operation. 
    Two of the most common communication primitives are the teleportation-based protocol (TP) and the cat-entangler based protocol (CAT):

    <figure style="max-width: min(100%, 600px); height: auto;text-align: center; margin: 20px 0;">
      <img src="../images/cat_tp.png" alt="CAT and TP implementation of CX gate" style="max-width: 80%; height: auto;">
      <figcaption style="margin-top: 10px; font-style: italic; color: #666;">
        Teleportation (TP) or cat-entagler (CAT) based implementations of non-local CX gates between qubits in different QPUs.
        Taken from <a href="https://arxiv.org/pdf/2207.11674" target="_blank">AutoComm: A Framework for Enabling Efficient Communication in Distributed Quantum Programs</a>.
        Note the M gate corresponds to measurements and the squiggly line between qubits to pre-entangled shared pairs amongst QPUs.
        The need for these pre-shared entangled pairs is why entanglement generation and routing is such a crucial part of quantum networking research.
      </figcaption>
    </figure>

    They have different resource requirements and performance characteristics, making them suitable for different scenarios.
    In general, TP is more qubit-efficient (requiring only 1 Bell pair/ebit per non-local gate) 
    but introduces classical communication latency because it requires classical feedback after Bell-state measurements to apply correction operations. 
    CAT requires more qubit overhead upfront (typically 4 qubits in a GHZ/cat state for implementing a non-local CNOT) 
    but can reduce the number of classical communication rounds, potentially lowering overall latency in high-latency networks. 
    The optimal choice depends on the qubit-communication trade-off and network topology.

  </div>

This encoding of computational dependencies is very useful because these inter-partition hyperedges (gates) can be "converted" into / interpreted as non-local gates,
meaning that they can serve as the communication primitive (the quantum instructions/info sent accross a quantum channel) to interweave the smaller computations into the larger computation we were originally distributing.
Conveniently, there is a very famous problem associated to this: <strong>the hypergraph partitioning problem</strong>.

</section>

<section> 
  <h2>Hypergraph partitioning: the problem</h2>
<!-- what the hypergraph problem is, how its not quite DQC but a starting point for the field, and how its hard -->
The hypergraph partitioning problem is probably on of the most investigated NP-hard problems in computer science. 
At its core, the problem consists on dividing the nodes of a hypergraph into disjoint subsets (partitions) such that:
<ol>
<li> The number of <strong>hyperedges</strong> that <strong>connect</strong> nodes in different <strong>partitions</strong> (the cut size) is <strong>minimized</strong>.</li>
<li> While ensuring that the <strong>partitions are balanced</strong> in size (i.e., each partition has roughly the same number of nodes).</li>
</ol>

    <figure style="max-width: min(100%, 1200px); height: auto;text-align: center; margin: 20px 0;">
      <img src="../images/kahy.png" alt="KaHyPar hypergraph partitioning visualisation" style="max-width: 80%; height: auto;">
      <figcaption style="margin-top: 10px; font-style: italic; color: #666;">
        My favourite showcase of the hypergraph problem from the <a href="https://kahypar.org" target="_blank">kahypar</a> team (kahypar is a popular hypergraph state of the art partitioning solver, which we will explore later in this post).
      </figcaption>
    </figure>

Hypergraph partitioning has had countless applications in VLSI chip design, parallel scientific computing, movie recommendation systems, and DNA sequence assembly.
Seeing why its NP hard is not too difficult, as it generalizes the graph partitioning problem, which is already NP-hard, 
and its not too hard to see that the number of possible partitions grows exponentially with the number of nodes and hyperedges in the hypergraph.

<br><br>

NP -> heuristics, and good heuristics are expensive. 
In distributed systems today (coming back to the classical world), 
you need to make partitioning decisions quickly, 
making complex heuristics prohibitive.
Classical distributed systems researchers often dealt with highly dynamic messy scenarios where the hypergraph structure changes rapidly, 
making the overhead of re-partitioning exceed any benefits from better partitioning. 
Hypergraph partitioning is just not the way for classical distributed systems today, 
but we can perhaps all agree that DQC today is far from that setting. 
Its messy, but for other reasons. 
Making hypergraph partitioning a more viable option, at least in the short term.

<br><br>

Yet, I don't want to be too discouraging of hypergraph abstractions in DQC. 
They are a very natural way to represent crucial dependencies in distributed quantum computations, 
which may not exist in the same form in classical distributed systems.
In classical systems you have what we could call "classical dependencies", meaning you require the result from an operation before you complete the next.
These can be modeled with graphs, as pairwise dependencies, and fit nicely in queueing systems.
In DQC however, you have "quantum dependencies", meaning that certain operations require entanglement. 
These dependies require both the previously mentioned classical dependency as well as the consumption (and thus availability) of a specific resource (entanglement).
They are not pairwise, as entanglement can exist between multiple qubits (GHZ states, W states, etc); 
and furthermore they are absolutely everywhere. 
Hypergraphs may be the way to go in DQC if we're talking about taking a massive monolithic circuit and mapping it down to a network of collaborating devices. 
Note that although this is my area of work at the moment, it doesn't have to be the way foward, and it certainly isn't how we run things in classical distributed systems today. 
(I keep talking about classical systems because they are the precursor to all of this DQC melarchy.)

<br><br>


That being said, although I do have a soft spot for hypergraph abstractions, THE hypergraph problem will see the wrath of my hammer.
It's first goal is all good and dandy, we do want to minimize inter-partition hyperedges, they are expensive, consume resource, and introduce noise, all generally bad things.
<br> 
But "balancing partitions"?!?!?! Why on earth do we care about balancing partitions? 
Perhaps this hatred comes from my inate abuse of any computational resource I am presented with.

    <figure style="max-width: min(100%, 400px); height: auto;text-align: center; margin: 20px 0;">
      <img src="../images/crazy.jpg" alt="8310m Jupyter notebook timer" style="max-width: 80%; height: auto;">
      <figcaption style="margin-top: 10px; font-style: italic; color: #666;">
        My current record taly (which I update when I remember to) of longest running Jupyter notebooks my poor laptop has to deal with <a href="https://bsky.app/profile/grageragarces.github.io/post/3m224vyj3cc2y" target="_blank">(Bluesky link)</a>. 
        8310m = 138.5 hours = 5.77 days
      </figcaption>
    </figure>

But I do have a point: unless driven by some specific hardware constraint (such as a decay in gate fidelity based on qubit load, which to my knowledge doesn't exist in today's QPUs), 
there is no inherent need to balance partitions in DQC. 
What we care about is:
<ol>
<li>  Minimizing the overall resource consumption (entanglement, qubits, time).</li>
<li>  Maximizing the overall fidelity of the distributed computation.</li>
<li>  <strong>Actually respecting the hardware constraints of the devices.</strong></li>
</ol>
Balancing is pointless, and irrelevant. 
Respecting device capacities is not only mandatory and a necessity, but like THE WHOLE FREAKING POINT! 
We are distributing or talking about distribution today because we cannot and believe that we will not be able to fit large computations in a single QPU. 
The whole field and concept of DQC starts from the idea of trying to find a solution to device capacities. 
And yes, you could argue balanced partitions can be somewhat interpreted as "capacities", but really they don't ensure hard constraints, 
and whats worse they absolutely do not help in heterogeneous settups where we may have different devices working together. 

<br><br>
<strong>TLDR:</strong> the hypergraph partitioning problem is not DQC, its a nice starting point, lets get over it. <br>
Nonetheless, the point of this post <u>is</u> to explore hypergraph partitioning in DQC, so with my rant out of the way, let's talk about some of the cool maths and cs behind hypergraphs in DQC.

</section>

<section> 
  <h2>Heuristics: State of the art</h2>
NP-hard problem implies heuristics.

    <div style="background-color:#fff8dc; border-left:4px solid #e6d87c; padding:10px 15px; margin:10px 0;">
  <strong>Heuristic:</strong> a practical approach to solving a problem that employs a method not guaranteed to be optimal or perfect. 
  They can often have performance guarantees, but by definition they are not exact algorithms.
  Heuristics can include approximation algorithms, probabilistic methods, greedy algorithms, and metaheuristics (overarching approaches that tell you how to explore the solution space rather than a specific method. e.g. Genetic Algorithms, Simulated Annealing).
  They are often used for NP-hard problems where exact solutions are computationally infeasible.
    </div>
  
Let's talk about them some of the most popular heuristics for hypergraph partitioning today (namely the specific problem I defined above).

<br>

<h3> Greedy and random: the simple path</h3>
Operates directly on the original hypergraph without hierarchical decomposition.

Greedy algorithms (e.g., greedy hypergraph growing)
Random partitioning
Spectral methods (eigenvalue-based)

<h3>Iterations: local search</h3>
Iteratively improves an existing partition by moving vertices between partitions.

FM (Fiduccia-Mattheyses) - classic move-based refinement
Kernighan-Lin variants
k-way FM extensions

<h3>Multilevel: the fancy pants solutions</h3>
Three-phase approach: coarsen → partition coarse graph → uncoarsen with refinement

KaHyPar (Karlsruhe Hypergraph Partitioner)
hMETIS
PaToH
Zoltan

<h3>Geometry: for the maths enthusiasts</h3>
Exploit spatial information when vertex coordinates are available.

Recursive coordinate bisection
Space-filling curves (Hilbert, Morton)
Geometric clustering

<h3>Metaheuristics: black box magic</h3>
Higher-level search strategies.

Genetic algorithms
Simulated annealing
Ant colony optimization

</section>

<section> 
  <h2>Hypergraph partitioning in DQC today</h2>
alternatives (graphs, himanshu work, hungarian): but hypergraphs are the most flexible

<br>

my own work with HDHs into model agnosticity
</section>


